/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const C3D_AspectRatioTop: f64 = 1.6666666666666667;
pub const C3D_AspectRatioBot: f64 = 1.3333333333333333;
pub const C3D_MTXSTACK_SIZE: u8 = 8;
pub const C3D_FVUNIF_COUNT: u8 = 96;
pub const C3D_IVUNIF_COUNT: u8 = 4;
pub const C3D_DEFAULT_CMDBUF_SIZE: u32 = 262144;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __uint64_t = ::libc::c_ulonglong;
pub type size_t = ::libc::c_uint;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s32 = i32;
pub type Result = s32;
#[doc = "< Top screen"]
pub const GFX_TOP: gfxScreen_t = 0;
#[doc = "< Bottom screen"]
pub const GFX_BOTTOM: gfxScreen_t = 1;
#[doc = " Screen IDs."]
pub type gfxScreen_t = ::libc::c_uint;
#[doc = "< Left eye framebuffer"]
pub const GFX_LEFT: gfx3dSide_t = 0;
#[doc = "< Right eye framebuffer"]
pub const GFX_RIGHT: gfx3dSide_t = 1;
#[doc = " @brief Top screen framebuffer side."]
#[doc = ""]
#[doc = " This is only meaningful when stereoscopic 3D is enabled on the top screen."]
#[doc = " In any other case, use \\ref GFX_LEFT."]
pub type gfx3dSide_t = ::libc::c_uint;
extern "C" {
    #[doc = " @brief Allocates a 0x80-byte aligned buffer."]
    #[doc = " @param size Size of the buffer to allocate."]
    #[doc = " @return The allocated buffer."]
    pub fn linearAlloc(size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " @brief Allocates a buffer aligned to the given size."]
    #[doc = " @param size Size of the buffer to allocate."]
    #[doc = " @param alignment Alignment to use."]
    #[doc = " @return The allocated buffer."]
    pub fn linearMemAlign(size: size_t, alignment: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " @brief Reallocates a buffer."]
    #[doc = " Note: Not implemented yet."]
    #[doc = " @param mem Buffer to reallocate."]
    #[doc = " @param size Size of the buffer to allocate."]
    #[doc = " @return The reallocated buffer."]
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " @brief Retrieves the allocated size of a buffer."]
    #[doc = " @return The size of the buffer."]
    pub fn linearGetSize(mem: *mut ::libc::c_void) -> size_t;
}
extern "C" {
    #[doc = " @brief Frees a buffer."]
    #[doc = " @param mem Buffer to free."]
    pub fn linearFree(mem: *mut ::libc::c_void);
}
extern "C" {
    #[doc = " @brief Gets the current linear free space."]
    #[doc = " @return The current linear free space."]
    pub fn linearSpaceFree() -> u32_;
}
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
#[doc = " @brief Supported transfer pixel formats."]
#[doc = " @sa GSPGPU_FramebufferFormat"]
pub type GX_TRANSFER_FORMAT = ::libc::c_uint;
#[doc = "< No anti-aliasing"]
pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
#[doc = "< 2x1 anti-aliasing"]
pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
#[doc = "< 2x2 anti-aliasing"]
pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
#[doc = " @brief Anti-aliasing modes"]
#[doc = ""]
#[doc = " Please remember that the framebuffer is sideways."]
#[doc = " Hence if you activate 2x1 anti-aliasing the destination dimensions are w = 240*2 and h = 400"]
pub type GX_TRANSFER_SCALE = ::libc::c_uint;
#[doc = "< Trigger the PPF event"]
pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
#[doc = "< Indicates if the memory fill is complete. You should not use it when requesting a transfer."]
pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
#[doc = "< The buffer has a 16 bit per pixel depth"]
pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
#[doc = "< The buffer has a 24 bit per pixel depth"]
pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
#[doc = "< The buffer has a 32 bit per pixel depth"]
pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
#[doc = " GX transfer control flags"]
pub type GX_FILL_CONTROL = ::libc::c_uint;
#[doc = "< Nearest-neighbor interpolation."]
pub const GPU_NEAREST: GPU_TEXTURE_FILTER_PARAM = 0;
#[doc = "< Linear interpolation."]
pub const GPU_LINEAR: GPU_TEXTURE_FILTER_PARAM = 1;
#[doc = " Texture filters."]
pub type GPU_TEXTURE_FILTER_PARAM = ::libc::c_uint;
#[doc = "< Clamps to edge."]
pub const GPU_CLAMP_TO_EDGE: GPU_TEXTURE_WRAP_PARAM = 0;
#[doc = "< Clamps to border."]
pub const GPU_CLAMP_TO_BORDER: GPU_TEXTURE_WRAP_PARAM = 1;
#[doc = "< Repeats texture."]
pub const GPU_REPEAT: GPU_TEXTURE_WRAP_PARAM = 2;
#[doc = "< Repeats with mirrored texture."]
pub const GPU_MIRRORED_REPEAT: GPU_TEXTURE_WRAP_PARAM = 3;
#[doc = " Texture wrap modes."]
pub type GPU_TEXTURE_WRAP_PARAM = ::libc::c_uint;
#[doc = "< 2D texture"]
pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
#[doc = "< Cube map"]
pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
#[doc = "< 2D Shadow texture"]
pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
#[doc = "< Projection texture"]
pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
#[doc = "< Shadow cube map"]
pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
#[doc = "< Disabled"]
pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
#[doc = " Texture modes."]
pub type GPU_TEXTURE_MODE_PARAM = ::libc::c_uint;
#[doc = "< Texture unit 0."]
pub const GPU_TEXUNIT0: GPU_TEXUNIT = 1;
#[doc = "< Texture unit 1."]
pub const GPU_TEXUNIT1: GPU_TEXUNIT = 2;
#[doc = "< Texture unit 2."]
pub const GPU_TEXUNIT2: GPU_TEXUNIT = 4;
#[doc = " Supported texture units."]
pub type GPU_TEXUNIT = ::libc::c_uint;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RGB8: GPU_TEXCOLOR = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RGB565: GPU_TEXCOLOR = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
#[doc = "< 8-bit Luminance + 8-bit Alpha"]
pub const GPU_LA8: GPU_TEXCOLOR = 5;
#[doc = "< 8-bit Hi + 8-bit Lo"]
pub const GPU_HILO8: GPU_TEXCOLOR = 6;
#[doc = "< 8-bit Luminance"]
pub const GPU_L8: GPU_TEXCOLOR = 7;
#[doc = "< 8-bit Alpha"]
pub const GPU_A8: GPU_TEXCOLOR = 8;
#[doc = "< 4-bit Luminance + 4-bit Alpha"]
pub const GPU_LA4: GPU_TEXCOLOR = 9;
#[doc = "< 4-bit Luminance"]
pub const GPU_L4: GPU_TEXCOLOR = 10;
#[doc = "< 4-bit Alpha"]
pub const GPU_A4: GPU_TEXCOLOR = 11;
#[doc = "< ETC1 texture compression"]
pub const GPU_ETC1: GPU_TEXCOLOR = 12;
#[doc = "< ETC1 texture compression + 4-bit Alpha"]
pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
#[doc = " Supported texture formats."]
pub type GPU_TEXCOLOR = ::libc::c_uint;
#[doc = "< 2D face"]
pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
#[doc = "< +X face"]
pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
#[doc = "< -X face"]
pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
#[doc = "< +Y face"]
pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
#[doc = "< -Y face"]
pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
#[doc = "< +Z face"]
pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
#[doc = "< -Z face"]
pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
#[doc = " Texture faces."]
pub type GPU_TEXFACE = ::libc::c_uint;
#[doc = "< Clamp to zero."]
pub const GPU_PT_CLAMP_TO_ZERO: GPU_PROCTEX_CLAMP = 0;
#[doc = "< Clamp to edge."]
pub const GPU_PT_CLAMP_TO_EDGE: GPU_PROCTEX_CLAMP = 1;
#[doc = "< Symmetrical repeat."]
pub const GPU_PT_REPEAT: GPU_PROCTEX_CLAMP = 2;
#[doc = "< Mirrored repeat."]
pub const GPU_PT_MIRRORED_REPEAT: GPU_PROCTEX_CLAMP = 3;
#[doc = "< Pulse."]
pub const GPU_PT_PULSE: GPU_PROCTEX_CLAMP = 4;
#[doc = " Procedural texture clamp modes."]
pub type GPU_PROCTEX_CLAMP = ::libc::c_uint;
#[doc = "< U"]
pub const GPU_PT_U: GPU_PROCTEX_MAPFUNC = 0;
#[doc = "< U2"]
pub const GPU_PT_U2: GPU_PROCTEX_MAPFUNC = 1;
#[doc = "< V"]
pub const GPU_PT_V: GPU_PROCTEX_MAPFUNC = 2;
#[doc = "< V2"]
pub const GPU_PT_V2: GPU_PROCTEX_MAPFUNC = 3;
#[doc = "< U+V"]
pub const GPU_PT_ADD: GPU_PROCTEX_MAPFUNC = 4;
#[doc = "< U2+V2"]
pub const GPU_PT_ADD2: GPU_PROCTEX_MAPFUNC = 5;
#[doc = "< sqrt(U2+V2)"]
pub const GPU_PT_SQRT2: GPU_PROCTEX_MAPFUNC = 6;
#[doc = "< min"]
pub const GPU_PT_MIN: GPU_PROCTEX_MAPFUNC = 7;
#[doc = "< max"]
pub const GPU_PT_MAX: GPU_PROCTEX_MAPFUNC = 8;
#[doc = "< rmax"]
pub const GPU_PT_RMAX: GPU_PROCTEX_MAPFUNC = 9;
#[doc = " Procedural texture mapping functions."]
pub type GPU_PROCTEX_MAPFUNC = ::libc::c_uint;
#[doc = "< No shift."]
pub const GPU_PT_NONE: GPU_PROCTEX_SHIFT = 0;
#[doc = "< Odd shift."]
pub const GPU_PT_ODD: GPU_PROCTEX_SHIFT = 1;
#[doc = "< Even shift."]
pub const GPU_PT_EVEN: GPU_PROCTEX_SHIFT = 2;
#[doc = " Procedural texture shift values."]
pub type GPU_PROCTEX_SHIFT = ::libc::c_uint;
#[doc = "< Nearest-neighbor"]
pub const GPU_PT_NEAREST: GPU_PROCTEX_FILTER = 0;
#[doc = "< Linear interpolation"]
pub const GPU_PT_LINEAR: GPU_PROCTEX_FILTER = 1;
#[doc = "< Nearest-neighbor with mipmap using nearest-neighbor"]
pub const GPU_PT_NEAREST_MIP_NEAREST: GPU_PROCTEX_FILTER = 2;
#[doc = "< Linear interpolation with mipmap using nearest-neighbor"]
pub const GPU_PT_LINEAR_MIP_NEAREST: GPU_PROCTEX_FILTER = 3;
#[doc = "< Nearest-neighbor with mipmap using linear interpolation"]
pub const GPU_PT_NEAREST_MIP_LINEAR: GPU_PROCTEX_FILTER = 4;
#[doc = "< Linear interpolation with mipmap using linear interpolation"]
pub const GPU_PT_LINEAR_MIP_LINEAR: GPU_PROCTEX_FILTER = 5;
#[doc = " Procedural texture filter values."]
pub type GPU_PROCTEX_FILTER = ::libc::c_uint;
#[doc = "< Noise table"]
pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
#[doc = "< RGB mapping function table"]
pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
#[doc = "< Alpha mapping function table"]
pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
#[doc = "< Color table"]
pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
#[doc = "< Color difference table"]
pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
#[doc = " Procedural texture LUT IDs."]
pub type GPU_PROCTEX_LUTID = ::libc::c_uint;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
#[doc = " Supported color buffer formats."]
pub type GPU_COLORBUF = ::libc::c_uint;
#[doc = "< 16-bit Depth"]
pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
#[doc = "< 24-bit Depth"]
pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
#[doc = "< 24-bit Depth + 8-bit Stencil"]
pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
#[doc = " Supported depth buffer formats."]
pub type GPU_DEPTHBUF = ::libc::c_uint;
#[doc = "< Never pass."]
pub const GPU_NEVER: GPU_TESTFUNC = 0;
#[doc = "< Always pass."]
pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
#[doc = "< Pass if equal."]
pub const GPU_EQUAL: GPU_TESTFUNC = 2;
#[doc = "< Pass if not equal."]
pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
#[doc = "< Pass if less than."]
pub const GPU_LESS: GPU_TESTFUNC = 4;
#[doc = "< Pass if less than or equal."]
pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
#[doc = "< Pass if greater than."]
pub const GPU_GREATER: GPU_TESTFUNC = 6;
#[doc = "< Pass if greater than or equal."]
pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
#[doc = " Test functions."]
pub type GPU_TESTFUNC = ::libc::c_uint;
#[doc = "< Pass if greater than or equal."]
pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
#[doc = "< Pass if greater than."]
pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
#[doc = "< Pass if less than or equal."]
pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
#[doc = "< Pass if less than."]
pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
#[doc = " Early depth test functions."]
pub type GPU_EARLYDEPTHFUNC = ::libc::c_uint;
#[doc = "< Never pass (0)."]
pub const GPU_GAS_NEVER: GPU_GASDEPTHFUNC = 0;
#[doc = "< Always pass (1)."]
pub const GPU_GAS_ALWAYS: GPU_GASDEPTHFUNC = 1;
#[doc = "< Pass if greater than (1-X)."]
pub const GPU_GAS_GREATER: GPU_GASDEPTHFUNC = 2;
#[doc = "< Pass if less than (X)."]
pub const GPU_GAS_LESS: GPU_GASDEPTHFUNC = 3;
#[doc = " Gas depth functions."]
pub type GPU_GASDEPTHFUNC = ::libc::c_uint;
#[doc = "< Disable."]
pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
#[doc = "< Exclude pixels inside the scissor box."]
pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
#[doc = "< Exclude pixels outside of the scissor box."]
pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
#[doc = " Scissor test modes."]
pub type GPU_SCISSORMODE = ::libc::c_uint;
#[doc = "< Keep old value. (old_stencil)"]
pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
#[doc = "< Zero. (0)"]
pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
#[doc = "< Replace value. (ref)"]
pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
#[doc = "< Increment value. (old_stencil + 1 saturated to [0, 255])"]
pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
#[doc = "< Decrement value. (old_stencil - 1 saturated to [0, 255])"]
pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
#[doc = "< Invert value. (~old_stencil)"]
pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
#[doc = "< Increment value. (old_stencil + 1)"]
pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
#[doc = "< Decrement value. (old_stencil - 1)"]
pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
#[doc = " Stencil operations."]
pub type GPU_STENCILOP = ::libc::c_uint;
#[doc = "< Write red."]
pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
#[doc = "< Write green."]
pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
#[doc = "< Write blue."]
pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
#[doc = "< Write alpha."]
pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
#[doc = "< Write depth."]
pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
#[doc = "< Write all color components."]
pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
#[doc = "< Write all components."]
pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
#[doc = " Pixel write mask."]
pub type GPU_WRITEMASK = ::libc::c_uint;
#[doc = "< Add colors."]
pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
#[doc = "< Subtract colors."]
pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
#[doc = "< Reverse-subtract colors."]
pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
#[doc = "< Use the minimum color."]
pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
#[doc = "< Use the maximum color."]
pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
#[doc = " Blend modes."]
pub type GPU_BLENDEQUATION = ::libc::c_uint;
#[doc = "< Zero."]
pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
#[doc = "< One."]
pub const GPU_ONE: GPU_BLENDFACTOR = 1;
#[doc = "< Source color."]
pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
#[doc = "< Source color - 1."]
pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
#[doc = "< Destination color."]
pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
#[doc = "< Destination color - 1."]
pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
#[doc = "< Source alpha."]
pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
#[doc = "< Source alpha - 1."]
pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
#[doc = "< Destination alpha."]
pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
#[doc = "< Destination alpha - 1."]
pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
#[doc = "< Constant color."]
pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
#[doc = "< Constant color - 1."]
pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
#[doc = "< Constant alpha."]
pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
#[doc = "< Constant alpha - 1."]
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
#[doc = "< Saturated alpha."]
pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
#[doc = " Blend factors."]
pub type GPU_BLENDFACTOR = ::libc::c_uint;
#[doc = "< Clear."]
pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
#[doc = "< Bitwise AND."]
pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
#[doc = "< Reverse bitwise AND."]
pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
#[doc = "< Copy."]
pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
#[doc = "< Set."]
pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
#[doc = "< Inverted copy."]
pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
#[doc = "< No operation."]
pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
#[doc = "< Invert."]
pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
#[doc = "< Bitwise NAND."]
pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
#[doc = "< Bitwise OR."]
pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
#[doc = "< Bitwise NOR."]
pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
#[doc = "< Bitwise XOR."]
pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
#[doc = "< Equivalent."]
pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
#[doc = "< Inverted bitwise AND."]
pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
#[doc = "< Reverse bitwise OR."]
pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
#[doc = "< Inverted bitwize OR."]
pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
#[doc = " Logical operations."]
pub type GPU_LOGICOP = ::libc::c_uint;
#[doc = "< OpenGL mode."]
pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
#[doc = "< Gas mode (?)."]
pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
#[doc = "< Shadow mode (?)."]
pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
#[doc = " Fragment operation modes."]
pub type GPU_FRAGOPMODE = ::libc::c_uint;
#[doc = "< 8-bit byte."]
pub const GPU_BYTE: GPU_FORMATS = 0;
#[doc = "< 8-bit unsigned byte."]
pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
#[doc = "< 16-bit short."]
pub const GPU_SHORT: GPU_FORMATS = 2;
#[doc = "< 32-bit float."]
pub const GPU_FLOAT: GPU_FORMATS = 3;
#[doc = " Supported component formats."]
pub type GPU_FORMATS = ::libc::c_uint;
#[doc = "< Disabled."]
pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
#[doc = "< Front, counter-clockwise."]
pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
#[doc = "< Back, counter-clockwise."]
pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
#[doc = " Cull modes."]
pub type GPU_CULLMODE = ::libc::c_uint;
#[doc = "< Primary color."]
pub const GPU_PRIMARY_COLOR: GPU_TEVSRC = 0;
#[doc = "< Primary fragment color."]
pub const GPU_FRAGMENT_PRIMARY_COLOR: GPU_TEVSRC = 1;
#[doc = "< Secondary fragment color."]
pub const GPU_FRAGMENT_SECONDARY_COLOR: GPU_TEVSRC = 2;
#[doc = "< Texture unit 0."]
pub const GPU_TEXTURE0: GPU_TEVSRC = 3;
#[doc = "< Texture unit 1."]
pub const GPU_TEXTURE1: GPU_TEVSRC = 4;
#[doc = "< Texture unit 2."]
pub const GPU_TEXTURE2: GPU_TEVSRC = 5;
#[doc = "< Texture unit 3."]
pub const GPU_TEXTURE3: GPU_TEVSRC = 6;
#[doc = "< Previous buffer."]
pub const GPU_PREVIOUS_BUFFER: GPU_TEVSRC = 13;
#[doc = "< Constant value."]
pub const GPU_CONSTANT: GPU_TEVSRC = 14;
#[doc = "< Previous value."]
pub const GPU_PREVIOUS: GPU_TEVSRC = 15;
#[doc = " Texture combiner sources."]
pub type GPU_TEVSRC = ::libc::c_uint;
#[doc = "< Source color."]
pub const GPU_TEVOP_RGB_SRC_COLOR: GPU_TEVOP_RGB = 0;
#[doc = "< Source color - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR: GPU_TEVOP_RGB = 1;
#[doc = "< Source alpha."]
pub const GPU_TEVOP_RGB_SRC_ALPHA: GPU_TEVOP_RGB = 2;
#[doc = "< Source alpha - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_RGB = 3;
#[doc = "< Source red."]
pub const GPU_TEVOP_RGB_SRC_R: GPU_TEVOP_RGB = 4;
#[doc = "< Source red - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_R: GPU_TEVOP_RGB = 5;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x06: GPU_TEVOP_RGB = 6;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x07: GPU_TEVOP_RGB = 7;
#[doc = "< Source green."]
pub const GPU_TEVOP_RGB_SRC_G: GPU_TEVOP_RGB = 8;
#[doc = "< Source green - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_G: GPU_TEVOP_RGB = 9;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0A: GPU_TEVOP_RGB = 10;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0B: GPU_TEVOP_RGB = 11;
#[doc = "< Source blue."]
pub const GPU_TEVOP_RGB_SRC_B: GPU_TEVOP_RGB = 12;
#[doc = "< Source blue - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_B: GPU_TEVOP_RGB = 13;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0E: GPU_TEVOP_RGB = 14;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0F: GPU_TEVOP_RGB = 15;
#[doc = " Texture RGB combiner operands."]
pub type GPU_TEVOP_RGB = ::libc::c_uint;
#[doc = "< Source alpha."]
pub const GPU_TEVOP_A_SRC_ALPHA: GPU_TEVOP_A = 0;
#[doc = "< Source alpha - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_A = 1;
#[doc = "< Source red."]
pub const GPU_TEVOP_A_SRC_R: GPU_TEVOP_A = 2;
#[doc = "< Source red - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_R: GPU_TEVOP_A = 3;
#[doc = "< Source green."]
pub const GPU_TEVOP_A_SRC_G: GPU_TEVOP_A = 4;
#[doc = "< Source green - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_G: GPU_TEVOP_A = 5;
#[doc = "< Source blue."]
pub const GPU_TEVOP_A_SRC_B: GPU_TEVOP_A = 6;
#[doc = "< Source blue - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_B: GPU_TEVOP_A = 7;
#[doc = " Texture Alpha combiner operands."]
pub type GPU_TEVOP_A = ::libc::c_uint;
#[doc = "< Replace."]
pub const GPU_REPLACE: GPU_COMBINEFUNC = 0;
#[doc = "< Modulate."]
pub const GPU_MODULATE: GPU_COMBINEFUNC = 1;
#[doc = "< Add."]
pub const GPU_ADD: GPU_COMBINEFUNC = 2;
#[doc = "< Signed add."]
pub const GPU_ADD_SIGNED: GPU_COMBINEFUNC = 3;
#[doc = "< Interpolate."]
pub const GPU_INTERPOLATE: GPU_COMBINEFUNC = 4;
#[doc = "< Subtract."]
pub const GPU_SUBTRACT: GPU_COMBINEFUNC = 5;
#[doc = "< Dot3. RGB only."]
pub const GPU_DOT3_RGB: GPU_COMBINEFUNC = 6;
#[doc = "< Multiply then add."]
pub const GPU_MULTIPLY_ADD: GPU_COMBINEFUNC = 8;
#[doc = "< Add then multiply."]
pub const GPU_ADD_MULTIPLY: GPU_COMBINEFUNC = 9;
#[doc = " Texture combiner functions."]
pub type GPU_COMBINEFUNC = ::libc::c_uint;
#[doc = "< 1x"]
pub const GPU_TEVSCALE_1: GPU_TEVSCALE = 0;
#[doc = "< 2x"]
pub const GPU_TEVSCALE_2: GPU_TEVSCALE = 1;
#[doc = "< 4x"]
pub const GPU_TEVSCALE_4: GPU_TEVSCALE = 2;
#[doc = " Texture scale factors."]
pub type GPU_TEVSCALE = ::libc::c_uint;
#[doc = "< None."]
pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
#[doc = "< Primary alpha."]
pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
#[doc = "< Secondary alpha."]
pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
#[doc = "< Primary and secondary alpha."]
pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
#[doc = " Fresnel options."]
pub type GPU_FRESNELSEL = ::libc::c_uint;
#[doc = "< Disabled."]
pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
#[doc = "< Bump as bump mapping."]
pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
#[doc = "< Bump as tangent/normal mapping."]
pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
#[doc = " Bump map modes."]
pub type GPU_BUMPMODE = ::libc::c_uint;
#[doc = "< D0 LUT."]
pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
#[doc = "< D1 LUT."]
pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
#[doc = "< Spotlight LUT."]
pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
#[doc = "< Fresnel LUT."]
pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
#[doc = "< Reflection-Blue LUT."]
pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
#[doc = "< Reflection-Green LUT."]
pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
#[doc = "< Reflection-Red LUT."]
pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
#[doc = " LUT IDs."]
pub type GPU_LIGHTLUTID = ::libc::c_uint;
#[doc = "< Normal*HalfVector"]
pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
#[doc = "< View*HalfVector"]
pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
#[doc = "< Normal*View"]
pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
#[doc = "< LightVector*Normal"]
pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
#[doc = "< -LightVector*SpotlightVector"]
pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
#[doc = "< cosine of phi"]
pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
#[doc = " LUT inputs."]
pub type GPU_LIGHTLUTINPUT = ::libc::c_uint;
#[doc = "< 1x scale."]
pub const GPU_LUTSCALER_1x: GPU_LIGHTLUTSCALER = 0;
#[doc = "< 2x scale."]
pub const GPU_LUTSCALER_2x: GPU_LIGHTLUTSCALER = 1;
#[doc = "< 4x scale."]
pub const GPU_LUTSCALER_4x: GPU_LIGHTLUTSCALER = 2;
#[doc = "< 8x scale."]
pub const GPU_LUTSCALER_8x: GPU_LIGHTLUTSCALER = 3;
#[doc = "< 0.25x scale."]
pub const GPU_LUTSCALER_0_25x: GPU_LIGHTLUTSCALER = 6;
#[doc = "< 0.5x scale."]
pub const GPU_LUTSCALER_0_5x: GPU_LIGHTLUTSCALER = 7;
#[doc = " LUT scalers."]
pub type GPU_LIGHTLUTSCALER = ::libc::c_uint;
#[doc = "< LUTs that are common to all lights."]
pub const GPU_LUTSELECT_COMMON: GPU_LIGHTLUTSELECT = 0;
#[doc = "< Spotlight LUT."]
pub const GPU_LUTSELECT_SP: GPU_LIGHTLUTSELECT = 1;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUTSELECT_DA: GPU_LIGHTLUTSELECT = 2;
#[doc = " LUT selection."]
pub type GPU_LIGHTLUTSELECT = ::libc::c_uint;
#[doc = "< Fog/Gas unit disabled."]
pub const GPU_NO_FOG: GPU_FOGMODE = 0;
#[doc = "< Fog/Gas unit configured in Fog mode."]
pub const GPU_FOG: GPU_FOGMODE = 5;
#[doc = "< Fog/Gas unit configured in Gas mode."]
pub const GPU_GAS: GPU_FOGMODE = 7;
#[doc = " Fog modes."]
pub type GPU_FOGMODE = ::libc::c_uint;
#[doc = "< Plain density."]
pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
#[doc = "< Depth density."]
pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
#[doc = " Gas shading density source values."]
pub type GPU_GASMODE = ::libc::c_uint;
#[doc = "< Gas density used as input."]
pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
#[doc = "< Light factor used as input."]
pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
#[doc = " Gas color LUT inputs."]
pub type GPU_GASLUTINPUT = ::libc::c_uint;
#[doc = "< Triangles."]
pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
#[doc = "< Triangle strip."]
pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
#[doc = "< Triangle fan."]
pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
#[doc = "< Geometry shader primitive."]
pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
#[doc = " Supported primitives."]
pub type GPU_Primitive_t = ::libc::c_uint;
#[doc = "< Vertex shader."]
pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
#[doc = "< Geometry shader."]
pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
#[doc = " Shader types."]
pub type GPU_SHADER_TYPE = ::libc::c_uint;
#[doc = "< Vertex shader."]
pub const VERTEX_SHDR: DVLE_type = 0;
#[doc = "< Geometry shader."]
pub const GEOMETRY_SHDR: DVLE_type = 1;
#[doc = " DVLE type."]
pub type DVLE_type = ::libc::c_uint;
#[doc = "< Point processing mode."]
pub const GSH_POINT: DVLE_geoShaderMode = 0;
#[doc = "< Variable-size primitive processing mode."]
pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
#[doc = "< Fixed-size primitive processing mode."]
pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
#[doc = " Geometry shader operation modes."]
pub type DVLE_geoShaderMode = ::libc::c_uint;
#[doc = " DVLP data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLP_s {
    #[doc = "< Code size."]
    pub codeSize: u32_,
    #[doc = "< Code data."]
    pub codeData: *mut u32_,
    #[doc = "< Operand description size."]
    pub opdescSize: u32_,
    #[doc = "< Operand description data."]
    pub opcdescData: *mut u32_,
}
#[doc = " DVLE constant entry data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_constEntry_s {
    #[doc = "< Constant type. See @ref DVLE_constantType"]
    pub type_: u16_,
    #[doc = "< Constant ID."]
    pub id: u16_,
    #[doc = "< Constant data."]
    pub data: [u32_; 4usize],
}
#[doc = " DVLE output entry data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_outEntry_s {
    #[doc = "< Output type. See @ref DVLE_outputAttribute_t"]
    pub type_: u16_,
    #[doc = "< Output register ID."]
    pub regID: u16_,
    #[doc = "< Output mask."]
    pub mask: u8_,
    #[doc = "< Unknown."]
    pub unk: [u8_; 3usize],
}
#[doc = " DVLE uniform entry data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_uniformEntry_s {
    #[doc = "< Symbol offset."]
    pub symbolOffset: u32_,
    #[doc = "< Start register."]
    pub startReg: u16_,
    #[doc = "< End register."]
    pub endReg: u16_,
}
#[doc = " DVLE data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_s {
    #[doc = "< DVLE type."]
    pub type_: DVLE_type,
    #[doc = "< true = merge vertex/geometry shader outmaps ('dummy' output attribute is present)."]
    pub mergeOutmaps: bool,
    #[doc = "< Geometry shader operation mode."]
    pub gshMode: DVLE_geoShaderMode,
    #[doc = "< Starting float uniform register number for storing the fixed-size primitive vertex array."]
    pub gshFixedVtxStart: u8_,
    #[doc = "< Number of fully-defined vertices in the variable-size primitive vertex array."]
    pub gshVariableVtxNum: u8_,
    #[doc = "< Number of vertices in the fixed-size primitive vertex array."]
    pub gshFixedVtxNum: u8_,
    #[doc = "< Contained DVLPs."]
    pub dvlp: *mut DVLP_s,
    #[doc = "< Offset of the start of the main function."]
    pub mainOffset: u32_,
    #[doc = "< Offset of the end of the main function."]
    pub endmainOffset: u32_,
    #[doc = "< Constant table size."]
    pub constTableSize: u32_,
    #[doc = "< Constant table data."]
    pub constTableData: *mut DVLE_constEntry_s,
    #[doc = "< Output table size."]
    pub outTableSize: u32_,
    #[doc = "< Output table data."]
    pub outTableData: *mut DVLE_outEntry_s,
    #[doc = "< Uniform table size."]
    pub uniformTableSize: u32_,
    #[doc = "< Uniform table data."]
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    #[doc = "< Symbol table data."]
    pub symbolTableData: *mut ::libc::c_char,
    #[doc = "< Output map mask."]
    pub outmapMask: u8_,
    #[doc = "< Output map data."]
    pub outmapData: [u32_; 8usize],
    #[doc = "< Output map mode."]
    pub outmapMode: u32_,
    #[doc = "< Output map attribute clock."]
    pub outmapClock: u32_,
}
#[doc = " DVLB data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLB_s {
    #[doc = "< DVLE count."]
    pub numDVLE: u32_,
    #[doc = "< Primary DVLP."]
    pub DVLP: DVLP_s,
    #[doc = "< Contained DVLE."]
    pub DVLE: *mut DVLE_s,
}
extern "C" {
    #[doc = " @brief Parses a shader binary."]
    #[doc = " @param shbinData Shader binary data."]
    #[doc = " @param shbinSize Shader binary size."]
    #[doc = " @return The parsed shader binary."]
    pub fn DVLB_ParseFile(shbinData: *mut u32_, shbinSize: u32_) -> *mut DVLB_s;
}
extern "C" {
    #[doc = " @brief Frees shader binary data."]
    #[doc = " @param dvlb DVLB to free."]
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
#[doc = " 24-bit float uniforms."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct float24Uniform_s {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[doc = " Describes an instance of either a vertex or geometry shader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderInstance_s {
    #[doc = "< Shader DVLE."]
    pub dvle: *mut DVLE_s,
    #[doc = "< Boolean uniforms."]
    pub boolUniforms: u16_,
    #[doc = "< Used boolean uniform mask."]
    pub boolUniformMask: u16_,
    #[doc = "< Integer uniforms."]
    pub intUniforms: [u32_; 4usize],
    #[doc = "< 24-bit float uniforms."]
    pub float24Uniforms: *mut float24Uniform_s,
    #[doc = "< Used integer uniform mask."]
    pub intUniformMask: u8_,
    #[doc = "< Float uniform count."]
    pub numFloat24Uniforms: u8_,
}
#[doc = " Describes an instance of a full shader program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderProgram_s {
    #[doc = "< Vertex shader."]
    pub vertexShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader."]
    pub geometryShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader input permutation."]
    pub geoShaderInputPermutation: [u32_; 2usize],
    #[doc = "< Geometry shader input stride."]
    pub geoShaderInputStride: u8_,
}
extern "C" {
    #[must_use]
    #[doc = " @brief Initializes a shader instance."]
    #[doc = " @param si Shader instance to initialize."]
    #[doc = " @param dvle DVLE to initialize the shader instance with."]
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Frees a shader instance."]
    #[doc = " @param si Shader instance to free."]
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Sets a bool uniform of a shader."]
    #[doc = " @param si Shader instance to use."]
    #[doc = " @param id ID of the bool uniform."]
    #[doc = " @param value Value to set."]
    pub fn shaderInstanceSetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Gets a bool uniform of a shader."]
    #[doc = " @param si Shader instance to use."]
    #[doc = " @param id ID of the bool uniform."]
    #[doc = " @param value Pointer to output the value to."]
    pub fn shaderInstanceGetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: *mut bool,
    ) -> Result;
}
extern "C" {
    #[doc = " @brief Gets the location of a shader's uniform."]
    #[doc = " @param si Shader instance to use."]
    #[doc = " @param name Name of the uniform."]
    pub fn shaderInstanceGetUniformLocation(
        si: *mut shaderInstance_s,
        name: *const ::libc::c_char,
    ) -> s8;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Initializes a shader program."]
    #[doc = " @param sp Shader program to initialize."]
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Frees a shader program."]
    #[doc = " @param sp Shader program to free."]
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Sets the vertex shader of a shader program."]
    #[doc = " @param sp Shader program to use."]
    #[doc = " @param dvle Vertex shader to set."]
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Sets the geometry shader of a shader program."]
    #[doc = " @param sp Shader program to use."]
    #[doc = " @param dvle Geometry shader to set."]
    #[doc = " @param stride Input stride of the shader (pass 0 to match the number of outputs of the vertex shader)."]
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s, stride: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Configures the permutation of the input attributes of the geometry shader of a shader program."]
    #[doc = " @param sp Shader program to use."]
    #[doc = " @param permutation Attribute permutation to use."]
    pub fn shaderProgramSetGshInputPermutation(
        sp: *mut shaderProgram_s,
        permutation: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Configures the shader units to use the specified shader program."]
    #[doc = " @param sp Shader program to use."]
    #[doc = " @param sendVshCode When true, the vertex shader's code and operand descriptors are uploaded."]
    #[doc = " @param sendGshCode When true, the geometry shader's code and operand descriptors are uploaded."]
    pub fn shaderProgramConfigure(
        sp: *mut shaderProgram_s,
        sendVshCode: bool,
        sendGshCode: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = " @brief Same as shaderProgramConfigure, but always loading code/operand descriptors and uploading DVLE constants afterwards."]
    #[doc = " @param sp Shader program to use."]
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
pub type C3D_IVec = u32_;
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    #[doc = " @brief Raw access"]
    pub c: [f32; 4usize],
}
#[doc = " @brief Vector access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    #[doc = "< W-component"]
    pub w: f32,
    #[doc = "< Z-component"]
    pub z: f32,
    #[doc = "< Y-component"]
    pub y: f32,
    #[doc = "< X-component"]
    pub x: f32,
}
#[doc = " @brief Quaternion access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    #[doc = "< Real component"]
    pub r: f32,
    #[doc = "< K-component"]
    pub k: f32,
    #[doc = "< J-component"]
    pub j: f32,
    #[doc = "< I-component"]
    pub i: f32,
}
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
pub type C3D_FQuat = C3D_FVec;
#[doc = " @struct C3D_Mtx"]
#[doc = " @brief Row-major 4x4 matrix"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    #[doc = "< Rows are vectors"]
    pub r: [C3D_FVec; 4usize],
    #[doc = "< Raw access"]
    pub m: [f32; 16usize],
}
extern "C" {
    #[doc = "@brief Transposes the matrix. Row => Column, and vice versa."]
    #[doc = "@param[in,out] out     Output matrix."]
    pub fn Mtx_Transpose(out: *mut C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Multiply two matrices"]
    #[doc = " @param[out] out Output matrix"]
    #[doc = " @param[in]  a   Multiplicand"]
    #[doc = " @param[in]  b   Multiplier"]
    pub fn Mtx_Multiply(out: *mut C3D_Mtx, a: *const C3D_Mtx, b: *const C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Inverse a matrix"]
    #[doc = " @param[in,out] out Matrix to inverse"]
    #[doc = " @retval 0.0f Degenerate matrix (no inverse)"]
    #[doc = " @return determinant"]
    pub fn Mtx_Inverse(out: *mut C3D_Mtx) -> f32;
}
extern "C" {
    #[doc = " @brief Multiply 3x3 matrix by a FVec3"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec3(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Multiply 4x4 matrix by a FVec4"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec4(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Get 4x4 matrix equivalent to Quaternion"]
    #[doc = " @param[out] m Output matrix"]
    #[doc = " @param[in]  q Input Quaternion"]
    pub fn Mtx_FromQuat(m: *mut C3D_Mtx, q: C3D_FQuat);
}
extern "C" {
    #[doc = " @brief 3D translation"]
    #[doc = " @param[in,out] mtx Matrix to translate"]
    #[doc = " @param[in]     x            X component to translate"]
    #[doc = " @param[in]     y            Y component to translate"]
    #[doc = " @param[in]     z            Z component to translate"]
    #[doc = " @param[in]     bRightSide   Whether to transform from the right side"]
    pub fn Mtx_Translate(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Scale"]
    #[doc = " @param[in,out] mtx Matrix to scale"]
    #[doc = " @param[in]     x   X component to scale"]
    #[doc = " @param[in]     y   Y component to scale"]
    #[doc = " @param[in]     z   Z component to scale"]
    pub fn Mtx_Scale(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " @brief 3D Rotation"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     axis       Axis about which to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_Rotate(mtx: *mut C3D_Mtx, axis: C3D_FVec, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the X axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateX(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Y axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateY(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Z axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateZ(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief Orthogonal projection"]
    #[doc = " @param[out] mtx Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_OrthoTilt"]
    pub fn Mtx_Ortho(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_Persp(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection"]
    #[doc = " @note Typically you will use iod to mean the distance between the eyes. Plug"]
    #[doc = "       in -iod for the left eye and iod for the right eye."]
    #[doc = " @note The focal length is defined by screen. If objects are further than this,"]
    #[doc = "       they will appear to be inside the screen. If objects are closer than this,"]
    #[doc = "       they will appear to pop out of the screen. Objects at this distance appear"]
    #[doc = "       to be at the screen."]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspStereo(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Orthogonal projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Ortho"]
    pub fn Mtx_OrthoTilt(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @note See the notes for @ref Mtx_PerspStereo"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    pub fn Mtx_PerspStereoTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Look-At matrix, based on DirectX implementation"]
    #[doc = " @note See https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342"]
    #[doc = " @param[out] out            Output matrix."]
    #[doc = " @param[in]  cameraPosition Position of the intended camera in 3D space."]
    #[doc = " @param[in]  cameraTarget   Position of the intended target the camera is supposed to face in 3D space."]
    #[doc = " @param[in]  cameraUpVector The vector that points straight up depending on the camera's \"Up\" direction."]
    #[doc = " @param[in]  isLeftHanded   Whether to build a LH projection"]
    pub fn Mtx_LookAt(
        out: *mut C3D_Mtx,
        cameraPosition: C3D_FVec,
        cameraTarget: C3D_FVec,
        cameraUpVector: C3D_FVec,
        isLeftHanded: bool,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_MtxStack {
    pub m: [C3D_Mtx; 8usize],
    pub pos: ::libc::c_int,
    pub unifType: u8_,
    pub unifPos: u8_,
    pub unifLen: u8_,
    pub isDirty: bool,
}
extern "C" {
    pub static mut C3D_FVUnif: [[C3D_FVec; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnif: [[C3D_IVec; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifs: [u16_; 2usize];
}
extern "C" {
    pub static mut C3D_FVUnifDirty: [[bool; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnifDirty: [[bool; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifsDirty: [bool; 2usize];
}
extern "C" {
    pub fn C3D_UpdateUniforms(type_: GPU_SHADER_TYPE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_AttrInfo {
    pub flags: [u32_; 2usize],
    pub permutation: u64_,
    pub attrCount: ::libc::c_int,
}
extern "C" {
    pub fn AttrInfo_Init(info: *mut C3D_AttrInfo);
}
extern "C" {
    pub fn AttrInfo_AddLoader(
        info: *mut C3D_AttrInfo,
        regId: ::libc::c_int,
        format: GPU_FORMATS,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn AttrInfo_AddFixed(info: *mut C3D_AttrInfo, regId: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetAttrInfo() -> *mut C3D_AttrInfo;
}
extern "C" {
    pub fn C3D_SetAttrInfo(info: *mut C3D_AttrInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufCfg {
    pub offset: u32_,
    pub flags: [u32_; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufInfo {
    pub base_paddr: u32_,
    pub bufCount: ::libc::c_int,
    pub buffers: [C3D_BufCfg; 12usize],
}
extern "C" {
    pub fn BufInfo_Init(info: *mut C3D_BufInfo);
}
extern "C" {
    pub fn BufInfo_Add(
        info: *mut C3D_BufInfo,
        data: *const ::libc::c_void,
        stride: isize,
        attribCount: ::libc::c_int,
        permutation: u64_,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetBufInfo() -> *mut C3D_BufInfo;
}
extern "C" {
    pub fn C3D_SetBufInfo(info: *mut C3D_BufInfo);
}
pub const C3D_UNSIGNED_BYTE: _bindgen_ty_38 = 0;
pub const C3D_UNSIGNED_SHORT: _bindgen_ty_38 = 1;
pub type _bindgen_ty_38 = ::libc::c_uint;
extern "C" {
    pub fn C3D_Init(cmdBufSize: size_t) -> bool;
}
extern "C" {
    pub fn C3D_Fini();
}
extern "C" {
    pub fn C3D_GetCmdBufUsage() -> f32;
}
extern "C" {
    pub fn C3D_BindProgram(program: *mut shaderProgram_s);
}
extern "C" {
    pub fn C3D_SetViewport(x: u32_, y: u32_, w: u32_, h: u32_);
}
extern "C" {
    pub fn C3D_SetScissor(mode: GPU_SCISSORMODE, left: u32_, top: u32_, right: u32_, bottom: u32_);
}
extern "C" {
    pub fn C3D_DrawArrays(primitive: GPU_Primitive_t, first: ::libc::c_int, size: ::libc::c_int);
}
extern "C" {
    pub fn C3D_DrawElements(
        primitive: GPU_Primitive_t,
        count: ::libc::c_int,
        type_: ::libc::c_int,
        indices: *const ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_ImmDrawBegin(primitive: GPU_Primitive_t);
}
extern "C" {
    pub fn C3D_ImmSendAttrib(x: f32, y: f32, z: f32, w: f32);
}
extern "C" {
    pub fn C3D_ImmDrawEnd();
}
extern "C" {
    pub fn C3D_FixedAttribGetWritePtr(id: ::libc::c_int) -> *mut C3D_FVec;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_TexEnv {
    pub srcRgb: u16_,
    pub srcAlpha: u16_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1,
    pub funcRgb: u16_,
    pub funcAlpha: u16_,
    pub color: u32_,
    pub scaleRgb: u16_,
    pub scaleAlpha: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_TexEnv__bindgen_ty_1 {
    pub opAll: u32_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn opRgb(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opRgb(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn opAlpha(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opAlpha(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(opRgb: u32_, opAlpha: u32_) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let opRgb: u32 = unsafe { ::core::mem::transmute(opRgb) };
            opRgb as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let opAlpha: u32 = unsafe { ::core::mem::transmute(opAlpha) };
            opAlpha as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_RGB: C3D_TexEnvMode = 1;
pub const C3D_Alpha: C3D_TexEnvMode = 2;
pub const C3D_Both: C3D_TexEnvMode = 3;
pub type C3D_TexEnvMode = ::libc::c_uint;
extern "C" {
    pub fn C3D_GetTexEnv(id: ::libc::c_int) -> *mut C3D_TexEnv;
}
extern "C" {
    pub fn C3D_SetTexEnv(id: ::libc::c_int, env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_DirtyTexEnv(env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_TexEnvBufUpdate(mode: ::libc::c_int, mask: ::libc::c_int);
}
extern "C" {
    pub fn C3D_TexEnvBufColor(color: u32_);
}
extern "C" {
    pub fn C3D_DepthMap(bIsZBuffer: bool, zScale: f32, zOffset: f32);
}
extern "C" {
    pub fn C3D_CullFace(mode: GPU_CULLMODE);
}
extern "C" {
    pub fn C3D_StencilTest(
        enable: bool,
        function: GPU_TESTFUNC,
        ref_: ::libc::c_int,
        inputMask: ::libc::c_int,
        writeMask: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_StencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP);
}
extern "C" {
    pub fn C3D_BlendingColor(color: u32_);
}
extern "C" {
    pub fn C3D_EarlyDepthTest(enable: bool, function: GPU_EARLYDEPTHFUNC, ref_: u32_);
}
extern "C" {
    pub fn C3D_DepthTest(enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK);
}
extern "C" {
    pub fn C3D_AlphaTest(enable: bool, function: GPU_TESTFUNC, ref_: ::libc::c_int);
}
extern "C" {
    pub fn C3D_AlphaBlend(
        colorEq: GPU_BLENDEQUATION,
        alphaEq: GPU_BLENDEQUATION,
        srcClr: GPU_BLENDFACTOR,
        dstClr: GPU_BLENDFACTOR,
        srcAlpha: GPU_BLENDFACTOR,
        dstAlpha: GPU_BLENDFACTOR,
    );
}
extern "C" {
    pub fn C3D_ColorLogicOp(op: GPU_LOGICOP);
}
extern "C" {
    pub fn C3D_FragOpMode(mode: GPU_FRAGOPMODE);
}
extern "C" {
    pub fn C3D_FragOpShadow(scale: f32, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> size_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: size_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: size_t) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexInitParams {
    pub width: u16_,
    pub height: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_TexInitParams {
    #[inline]
    pub fn maxLevel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_maxLevel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_format(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn onVram(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onVram(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maxLevel: u8_,
        format: GPU_TEXCOLOR,
        type_: GPU_TEXTURE_MODE_PARAM,
        onVram: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let maxLevel: u8 = unsafe { ::core::mem::transmute(maxLevel) };
            maxLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let format: u32 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let onVram: u8 = unsafe { ::core::mem::transmute(onVram) };
            onVram as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn C3D_TexInitWithParams(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        p: C3D_TexInitParams,
    ) -> bool;
}
extern "C" {
    pub fn C3D_TexLoadImage(
        tex: *mut C3D_Tex,
        data: *const ::libc::c_void,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_TexGenerateMipmap(tex: *mut C3D_Tex, face: GPU_TEXFACE);
}
extern "C" {
    pub fn C3D_TexBind(unitId: ::libc::c_int, tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexFlush(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexDelete(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexShadowParams(perspective: bool, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTexColorLut {
    pub color: [u32_; 256usize],
    pub diff: [u32_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTex {
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_ProcTex__bindgen_ty_2,
    pub __bindgen_anon_3: C3D_ProcTex__bindgen_ty_3,
    pub __bindgen_anon_4: C3D_ProcTex__bindgen_ty_4,
    pub __bindgen_anon_5: C3D_ProcTex__bindgen_ty_5,
    pub __bindgen_anon_6: C3D_ProcTex__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_1 {
    pub proctex0: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn uClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn vClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rgbFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaSeparate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSeparate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNoise(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enableNoise(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasLow(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasLow(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uClamp: u32_,
        vClamp: u32_,
        rgbFunc: u32_,
        alphaFunc: u32_,
        alphaSeparate: bool,
        enableNoise: bool,
        uShift: u32_,
        vShift: u32_,
        lodBiasLow: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let uClamp: u32 = unsafe { ::core::mem::transmute(uClamp) };
            uClamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vClamp: u32 = unsafe { ::core::mem::transmute(vClamp) };
            vClamp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let rgbFunc: u32 = unsafe { ::core::mem::transmute(rgbFunc) };
            rgbFunc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let alphaFunc: u32 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let alphaSeparate: u8 = unsafe { ::core::mem::transmute(alphaSeparate) };
            alphaSeparate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableNoise: u8 = unsafe { ::core::mem::transmute(enableNoise) };
            enableNoise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let uShift: u32 = unsafe { ::core::mem::transmute(uShift) };
            uShift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vShift: u32 = unsafe { ::core::mem::transmute(vShift) };
            vShift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let lodBiasLow: u32 = unsafe { ::core::mem::transmute(lodBiasLow) };
            lodBiasLow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_2 {
    pub proctex1: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 {
    pub uNoiseAmpl: u16_,
    pub uNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_3 {
    pub proctex2: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 {
    pub vNoiseAmpl: u16_,
    pub vNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_4 {
    pub proctex3: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 {
    pub uNoiseFreq: u16_,
    pub vNoiseFreq: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_5 {
    pub proctex4: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn minFilter(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_minFilter(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unknown1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasHigh(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasHigh(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minFilter: u32_,
        unknown1: u32_,
        width: u32_,
        lodBiasHigh: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let minFilter: u32 = unsafe { ::core::mem::transmute(minFilter) };
            minFilter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let unknown1: u32 = unsafe { ::core::mem::transmute(unknown1) };
            unknown1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let lodBiasHigh: u32 = unsafe { ::core::mem::transmute(lodBiasHigh) };
            lodBiasHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_6 {
    pub proctex5: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown2(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_unknown2(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32_, unknown2: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let unknown2: u32 = unsafe { ::core::mem::transmute(unknown2) };
            unknown2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_ProcTex_U: _bindgen_ty_39 = 1;
pub const C3D_ProcTex_V: _bindgen_ty_39 = 2;
pub const C3D_ProcTex_UV: _bindgen_ty_39 = 3;
pub type _bindgen_ty_39 = ::libc::c_uint;
extern "C" {
    pub fn C3D_ProcTexInit(pt: *mut C3D_ProcTex, offset: ::libc::c_int, length: ::libc::c_int);
}
extern "C" {
    pub fn C3D_ProcTexNoiseCoefs(
        pt: *mut C3D_ProcTex,
        mode: ::libc::c_int,
        amplitude: f32,
        frequency: f32,
        phase: f32,
    );
}
extern "C" {
    pub fn C3D_ProcTexLodBias(pt: *mut C3D_ProcTex, bias: f32);
}
extern "C" {
    pub fn C3D_ProcTexBind(texCoordId: ::libc::c_int, pt: *mut C3D_ProcTex);
}
pub type C3D_ProcTexLut = [u32_; 128usize];
extern "C" {
    pub fn C3D_ProcTexLutBind(id: GPU_PROCTEX_LUTID, lut: *mut C3D_ProcTexLut);
}
extern "C" {
    pub fn C3D_ProcTexColorLutBind(lut: *mut C3D_ProcTexColorLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLut {
    pub data: [u32_; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutDA {
    pub lut: C3D_LightLut,
    pub bias: f32,
    pub scale: f32,
}
pub type C3D_LightLutFunc = ::core::option::Option<unsafe extern "C" fn(x: f32, param: f32) -> f32>;
pub type C3D_LightLutFuncDA =
    ::core::option::Option<unsafe extern "C" fn(dist: f32, arg0: f32, arg1: f32) -> f32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Material {
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub emission: [f32; 3usize],
}
pub type C3D_Light = C3D_Light_t;
pub type C3D_LightEnv = C3D_LightEnv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutInputConf {
    pub abs: u32_,
    pub select: u32_,
    pub scale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnvConf {
    pub ambient: u32_,
    pub numLights: u32_,
    pub config: [u32_; 2usize],
    pub lutInput: C3D_LightLutInputConf,
    pub permutation: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnv_t {
    pub flags: u32_,
    pub luts: [*mut C3D_LightLut; 6usize],
    pub ambient: [f32; 3usize],
    pub lights: [*mut C3D_Light; 8usize],
    pub conf: C3D_LightEnvConf,
    pub material: C3D_Material,
}
extern "C" {
    pub fn C3D_LightEnvInit(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvBind(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvMaterial(env: *mut C3D_LightEnv, mtl: *const C3D_Material);
}
extern "C" {
    pub fn C3D_LightEnvAmbient(env: *mut C3D_LightEnv, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightEnvLut(
        env: *mut C3D_LightEnv,
        lutId: GPU_LIGHTLUTID,
        input: GPU_LIGHTLUTINPUT,
        negative: bool,
        lut: *mut C3D_LightLut,
    );
}
extern "C" {
    pub fn C3D_LightEnvFresnel(env: *mut C3D_LightEnv, selector: GPU_FRESNELSEL);
}
extern "C" {
    pub fn C3D_LightEnvBumpMode(env: *mut C3D_LightEnv, mode: GPU_BUMPMODE);
}
extern "C" {
    pub fn C3D_LightEnvBumpSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvShadowMode(env: *mut C3D_LightEnv, mode: u32_);
}
extern "C" {
    pub fn C3D_LightEnvShadowSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvClampHighlights(env: *mut C3D_LightEnv, clamp: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightMatConf {
    pub specular0: u32_,
    pub specular1: u32_,
    pub diffuse: u32_,
    pub ambient: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightConf {
    pub material: C3D_LightMatConf,
    pub position: [u16_; 3usize],
    pub padding0: u16_,
    pub spotDir: [u16_; 3usize],
    pub padding1: u16_,
    pub padding2: u32_,
    pub config: u32_,
    pub distAttnBias: u32_,
    pub distAttnScale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Light_t {
    pub flags: u16_,
    pub id: u16_,
    pub parent: *mut C3D_LightEnv,
    pub lut_SP: *mut C3D_LightLut,
    pub lut_DA: *mut C3D_LightLut,
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub conf: C3D_LightConf,
}
extern "C" {
    pub fn C3D_LightInit(light: *mut C3D_Light, env: *mut C3D_LightEnv) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_LightEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightTwoSideDiffuse(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightGeoFactor(light: *mut C3D_Light, id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn C3D_LightAmbient(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightDiffuse(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular0(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular1(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightPosition(light: *mut C3D_Light, pos: *mut C3D_FVec);
}
extern "C" {
    pub fn C3D_LightShadowEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotDir(light: *mut C3D_Light, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn C3D_LightSpotLut(light: *mut C3D_Light, lut: *mut C3D_LightLut);
}
extern "C" {
    pub fn C3D_LightDistAttnEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightDistAttn(light: *mut C3D_Light, lut: *mut C3D_LightLutDA);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FogLut {
    pub data: [u32_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_GasLut {
    pub diff: [u32_; 8usize],
    pub color: [u32_; 8usize],
}
extern "C" {
    pub fn C3D_FogGasMode(fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool);
}
extern "C" {
    pub fn C3D_FogColor(color: u32_);
}
extern "C" {
    pub fn C3D_FogLutBind(lut: *mut C3D_FogLut);
}
extern "C" {
    pub fn C3D_GasBeginAcc();
}
extern "C" {
    pub fn C3D_GasDeltaZ(value: f32);
}
extern "C" {
    pub fn C3D_GasAccMax(value: f32);
}
extern "C" {
    pub fn C3D_GasAttn(value: f32);
}
extern "C" {
    pub fn C3D_GasLightPlanar(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightView(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightDirection(dotp: f32);
}
extern "C" {
    pub fn C3D_GasLutInput(input: GPU_GASLUTINPUT);
}
extern "C" {
    pub fn C3D_GasLutBind(lut: *mut C3D_GasLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_CLEAR_COLOR: C3D_ClearBits = 1;
pub const C3D_CLEAR_DEPTH: C3D_ClearBits = 2;
pub const C3D_CLEAR_ALL: C3D_ClearBits = 3;
pub type C3D_ClearBits = ::libc::c_uint;
extern "C" {
    pub fn C3D_CalcColorBufSize(width: u32_, height: u32_, fmt: GPU_COLORBUF) -> u32_;
}
extern "C" {
    pub fn C3D_CalcDepthBufSize(width: u32_, height: u32_, fmt: GPU_DEPTHBUF) -> u32_;
}
extern "C" {
    pub fn C3D_GetFrameBuf() -> *mut C3D_FrameBuf;
}
extern "C" {
    pub fn C3D_SetFrameBuf(fb: *mut C3D_FrameBuf);
}
extern "C" {
    pub fn C3D_FrameBufTex(
        fb: *mut C3D_FrameBuf,
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_FrameBufClear(
        fb: *mut C3D_FrameBuf,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
extern "C" {
    pub fn C3D_FrameBufTransfer(
        fb: *mut C3D_FrameBuf,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
pub const C3D_FRAME_SYNCDRAW: _bindgen_ty_43 = 1;
pub const C3D_FRAME_NONBLOCK: _bindgen_ty_43 = 2;
pub type _bindgen_ty_43 = ::libc::c_uint;
extern "C" {
    pub fn C3D_FrameRate(fps: f32) -> f32;
}
extern "C" {
    pub fn C3D_FrameSync();
}
extern "C" {
    pub fn C3D_FrameCounter(id: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn C3D_FrameBegin(flags: u8_) -> bool;
}
extern "C" {
    pub fn C3D_FrameDrawOn(target: *mut C3D_RenderTarget) -> bool;
}
extern "C" {
    pub fn C3D_FrameSplit(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEnd(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEndHook(
        hook: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        param: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_GetDrawingTime() -> f32;
}
extern "C" {
    pub fn C3D_GetProcessingTime() -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_DEPTHTYPE {
    pub __i: ::libc::c_int,
    pub __e: GPU_DEPTHBUF,
}
extern "C" {
    pub fn C3D_RenderTargetCreate(
        width: ::libc::c_int,
        height: ::libc::c_int,
        colorFmt: GPU_COLORBUF,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetCreateFromTex(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetDelete(target: *mut C3D_RenderTarget);
}
extern "C" {
    pub fn C3D_RenderTargetSetOutput(
        target: *mut C3D_RenderTarget,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncDisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncTextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncMemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    );
}
