/* automatically generated by rust-bindgen 0.62.0 */

use ctru_sys::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const M_TAU: f64 = 6.283185307179586;
pub const C3D_AspectRatioTop: f64 = 1.6666666666666667;
pub const C3D_AspectRatioBot: f64 = 1.3333333333333333;
pub const C3D_MTXSTACK_SIZE: u8 = 8;
pub const C3D_FVUNIF_COUNT: u8 = 96;
pub const C3D_IVUNIF_COUNT: u8 = 4;
pub const C3D_DEFAULT_CMDBUF_SIZE: u32 = 262144;
pub const C3DF_LightEnv_IsCP_Any: u32 = 66846720;
pub const C3DF_LightEnv_LutDirtyAll: u32 = 4227858432;
pub type __int64_t = ::libc::c_longlong;
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type wint_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
}
pub type __ULong = ::libc::c_ulong;
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _unspecified_locale_info: ::libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::libc::c_uint,
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::libc::c_uchar; 30usize],
    pub _nmalloc: [::libc::c_uint; 30usize],
}
pub type C3D_IVec = u32_;
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    #[doc = " @brief Raw access"]
    pub c: [f32; 4usize],
}
#[doc = " @brief Vector access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    #[doc = "< W-component"]
    pub w: f32,
    #[doc = "< Z-component"]
    pub z: f32,
    #[doc = "< Y-component"]
    pub y: f32,
    #[doc = "< X-component"]
    pub x: f32,
}
#[doc = " @brief Quaternion access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    #[doc = "< Real component"]
    pub r: f32,
    #[doc = "< K-component"]
    pub k: f32,
    #[doc = "< J-component"]
    pub j: f32,
    #[doc = "< I-component"]
    pub i: f32,
}
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
pub type C3D_FQuat = C3D_FVec;
#[doc = " @struct C3D_Mtx"]
#[doc = " @brief Row-major 4x4 matrix"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    #[doc = "< Rows are vectors"]
    pub r: [C3D_FVec; 4usize],
    #[doc = "< Raw access"]
    pub m: [f32; 16usize],
}
extern "C" {
    #[doc = "@brief Transposes the matrix. Row => Column, and vice versa."]
    #[doc = "@param[in,out] out     Output matrix."]
    pub fn Mtx_Transpose(out: *mut C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Multiply two matrices"]
    #[doc = " @param[out] out Output matrix"]
    #[doc = " @param[in]  a   Multiplicand"]
    #[doc = " @param[in]  b   Multiplier"]
    pub fn Mtx_Multiply(out: *mut C3D_Mtx, a: *const C3D_Mtx, b: *const C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Inverse a matrix"]
    #[doc = " @param[in,out] out Matrix to inverse"]
    #[doc = " @retval 0.0f Degenerate matrix (no inverse)"]
    #[doc = " @return determinant"]
    pub fn Mtx_Inverse(out: *mut C3D_Mtx) -> f32;
}
extern "C" {
    #[doc = " @brief Multiply 3x3 matrix by a FVec3"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec3(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Multiply 4x4 matrix by a FVec4"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec4(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Get 4x4 matrix equivalent to Quaternion"]
    #[doc = " @param[out] m Output matrix"]
    #[doc = " @param[in]  q Input Quaternion"]
    pub fn Mtx_FromQuat(m: *mut C3D_Mtx, q: C3D_FQuat);
}
extern "C" {
    #[doc = " @brief 3D translation"]
    #[doc = " @param[in,out] mtx Matrix to translate"]
    #[doc = " @param[in]     x            X component to translate"]
    #[doc = " @param[in]     y            Y component to translate"]
    #[doc = " @param[in]     z            Z component to translate"]
    #[doc = " @param[in]     bRightSide   Whether to transform from the right side"]
    pub fn Mtx_Translate(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Scale"]
    #[doc = " @param[in,out] mtx Matrix to scale"]
    #[doc = " @param[in]     x   X component to scale"]
    #[doc = " @param[in]     y   Y component to scale"]
    #[doc = " @param[in]     z   Z component to scale"]
    pub fn Mtx_Scale(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " @brief 3D Rotation"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     axis       Axis about which to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_Rotate(mtx: *mut C3D_Mtx, axis: C3D_FVec, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the X axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateX(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Y axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateY(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Z axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateZ(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief Orthogonal projection"]
    #[doc = " @param[out] mtx Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_OrthoTilt"]
    pub fn Mtx_Ortho(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_Persp(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection"]
    #[doc = " @note Typically you will use iod to mean the distance between the eyes. Plug"]
    #[doc = "       in -iod for the left eye and iod for the right eye."]
    #[doc = " @note The focal length is defined by screen. If objects are further than this,"]
    #[doc = "       they will appear to be inside the screen. If objects are closer than this,"]
    #[doc = "       they will appear to pop out of the screen. Objects at this distance appear"]
    #[doc = "       to be at the screen."]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspStereo(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Orthogonal projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Ortho"]
    pub fn Mtx_OrthoTilt(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @note See the notes for @ref Mtx_PerspStereo"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    pub fn Mtx_PerspStereoTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Look-At matrix, based on DirectX implementation"]
    #[doc = " @note See https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342"]
    #[doc = " @param[out] out            Output matrix."]
    #[doc = " @param[in]  cameraPosition Position of the intended camera in 3D space."]
    #[doc = " @param[in]  cameraTarget   Position of the intended target the camera is supposed to face in 3D space."]
    #[doc = " @param[in]  cameraUpVector The vector that points straight up depending on the camera's \"Up\" direction."]
    #[doc = " @param[in]  isLeftHanded   Whether to build a LH projection"]
    pub fn Mtx_LookAt(
        out: *mut C3D_Mtx,
        cameraPosition: C3D_FVec,
        cameraTarget: C3D_FVec,
        cameraUpVector: C3D_FVec,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Multiply two Quaternions"]
    #[doc = " @param[in] lhs Multiplicand"]
    #[doc = " @param[in] rhs Multiplier"]
    #[doc = " @return lhs*rhs"]
    pub fn Quat_Multiply(lhs: C3D_FQuat, rhs: C3D_FQuat) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief Raise Quaternion to a power"]
    #[doc = " @note If p is 0, this returns the identity Quaternion."]
    #[doc = "       If p is 1, this returns q."]
    #[doc = " @param[in] q Base Quaternion"]
    #[doc = " @param[in] p Power"]
    #[doc = " @return q<sup>p</sup>"]
    pub fn Quat_Pow(q: C3D_FQuat, p: f32) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief Cross product of Quaternion and FVec3"]
    #[doc = " @param[in] q Base Quaternion"]
    #[doc = " @param[in] v Vector to cross"]
    #[doc = " @return qÃ—v"]
    pub fn Quat_CrossFVec3(q: C3D_FQuat, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief 3D Rotation"]
    #[doc = " @param[in] q          Quaternion to rotate"]
    #[doc = " @param[in] axis       Axis about which to rotate"]
    #[doc = " @param[in] r          Radians to rotate"]
    #[doc = " @param[in] bRightSide Whether to transform from the right side"]
    #[doc = " @return Rotated Quaternion"]
    pub fn Quat_Rotate(q: C3D_FQuat, axis: C3D_FVec, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief 3D Rotation about the X axis"]
    #[doc = " @param[in] q          Quaternion to rotate"]
    #[doc = " @param[in] r          Radians to rotate"]
    #[doc = " @param[in] bRightSide Whether to transform from the right side"]
    #[doc = " @return Rotated Quaternion"]
    pub fn Quat_RotateX(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Y axis"]
    #[doc = " @param[in] q          Quaternion to rotate"]
    #[doc = " @param[in] r          Radians to rotate"]
    #[doc = " @param[in] bRightSide Whether to transform from the right side"]
    #[doc = " @return Rotated Quaternion"]
    pub fn Quat_RotateY(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Z axis"]
    #[doc = " @param[in] q          Quaternion to rotate"]
    #[doc = " @param[in] r          Radians to rotate"]
    #[doc = " @param[in] bRightSide Whether to transform from the right side"]
    #[doc = " @return Rotated Quaternion"]
    pub fn Quat_RotateZ(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief Get Quaternion equivalent to 4x4 matrix"]
    #[doc = " @note If the matrix is orthogonal or special orthogonal, where determinant(matrix) = +1.0f, then the matrix can be converted."]
    #[doc = " @param[in]   m Input  Matrix"]
    #[doc = " @return      Generated Quaternion"]
    pub fn Quat_FromMtx(m: *const C3D_Mtx) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief Converting Pitch, Yaw, and Roll to Quaternion equivalent"]
    #[doc = " @param[in] pitch      The pitch angle in radians."]
    #[doc = " @param[in] yaw        The yaw angle in radians."]
    #[doc = " @param[in] roll       The roll angle in radians."]
    #[doc = " @param[in] bRightSide Whether to transform from the right side"]
    #[doc = " @return    C3D_FQuat  The Quaternion equivalent with the pitch, yaw, and roll (in that order) orientations applied."]
    pub fn Quat_FromPitchYawRoll(pitch: f32, yaw: f32, roll: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief Quaternion Look-At"]
    #[doc = " @param[in] source   C3D_FVec Starting position. Origin of rotation."]
    #[doc = " @param[in] target   C3D_FVec Target position to orient towards."]
    #[doc = " @param[in] forwardVector C3D_FVec The Up vector."]
    #[doc = " @param[in] upVector C3D_FVec The Up vector."]
    #[doc = " @return Quaternion rotation."]
    pub fn Quat_LookAt(
        source: C3D_FVec,
        target: C3D_FVec,
        forwardVector: C3D_FVec,
        upVector: C3D_FVec,
    ) -> C3D_FQuat;
}
extern "C" {
    #[doc = " @brief Quaternion, created from a given axis and angle in radians."]
    #[doc = " @param[in] axis  C3D_FVec The axis to rotate around at."]
    #[doc = " @param[in] angle float The angle to rotate. Unit: Radians"]
    #[doc = " @return Quaternion rotation based on the axis and angle. Axis doesn't have to be orthogonal."]
    pub fn Quat_FromAxisAngle(axis: C3D_FVec, angle: f32) -> C3D_FQuat;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_MtxStack {
    pub m: [C3D_Mtx; 8usize],
    pub pos: ::libc::c_int,
    pub unifType: u8_,
    pub unifPos: u8_,
    pub unifLen: u8_,
    pub isDirty: bool,
}
extern "C" {
    pub fn MtxStack_Init(stk: *mut C3D_MtxStack);
}
extern "C" {
    pub fn MtxStack_Bind(
        stk: *mut C3D_MtxStack,
        unifType: GPU_SHADER_TYPE,
        unifPos: ::libc::c_int,
        unifLen: ::libc::c_int,
    );
}
extern "C" {
    pub fn MtxStack_Push(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
extern "C" {
    pub fn MtxStack_Pop(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
extern "C" {
    pub fn MtxStack_Update(stk: *mut C3D_MtxStack);
}
extern "C" {
    pub static mut C3D_FVUnif: [[C3D_FVec; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnif: [[C3D_IVec; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifs: [u16_; 2usize];
}
extern "C" {
    pub static mut C3D_FVUnifDirty: [[bool; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnifDirty: [[bool; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifsDirty: [bool; 2usize];
}
extern "C" {
    pub fn C3D_UpdateUniforms(type_: GPU_SHADER_TYPE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_AttrInfo {
    pub flags: [u32_; 2usize],
    pub permutation: u64_,
    pub attrCount: ::libc::c_int,
}
extern "C" {
    pub fn AttrInfo_Init(info: *mut C3D_AttrInfo);
}
extern "C" {
    pub fn AttrInfo_AddLoader(
        info: *mut C3D_AttrInfo,
        regId: ::libc::c_int,
        format: GPU_FORMATS,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn AttrInfo_AddFixed(info: *mut C3D_AttrInfo, regId: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetAttrInfo() -> *mut C3D_AttrInfo;
}
extern "C" {
    pub fn C3D_SetAttrInfo(info: *mut C3D_AttrInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufCfg {
    pub offset: u32_,
    pub flags: [u32_; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufInfo {
    pub base_paddr: u32_,
    pub bufCount: ::libc::c_int,
    pub buffers: [C3D_BufCfg; 12usize],
}
extern "C" {
    pub fn BufInfo_Init(info: *mut C3D_BufInfo);
}
extern "C" {
    pub fn BufInfo_Add(
        info: *mut C3D_BufInfo,
        data: *const ::libc::c_void,
        stride: isize,
        attribCount: ::libc::c_int,
        permutation: u64_,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetBufInfo() -> *mut C3D_BufInfo;
}
extern "C" {
    pub fn C3D_SetBufInfo(info: *mut C3D_BufInfo);
}
pub const C3D_UNSIGNED_BYTE: _bindgen_ty_38 = 0;
pub const C3D_UNSIGNED_SHORT: _bindgen_ty_38 = 1;
pub type _bindgen_ty_38 = ::libc::c_uint;
extern "C" {
    pub fn C3D_Init(cmdBufSize: usize) -> bool;
}
extern "C" {
    pub fn C3D_Fini();
}
extern "C" {
    pub fn C3D_GetCmdBufUsage() -> f32;
}
extern "C" {
    pub fn C3D_BindProgram(program: *mut shaderProgram_s);
}
extern "C" {
    pub fn C3D_SetViewport(x: u32_, y: u32_, w: u32_, h: u32_);
}
extern "C" {
    pub fn C3D_SetScissor(mode: GPU_SCISSORMODE, left: u32_, top: u32_, right: u32_, bottom: u32_);
}
extern "C" {
    pub fn C3D_DrawArrays(primitive: GPU_Primitive_t, first: ::libc::c_int, size: ::libc::c_int);
}
extern "C" {
    pub fn C3D_DrawElements(
        primitive: GPU_Primitive_t,
        count: ::libc::c_int,
        type_: ::libc::c_int,
        indices: *const ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_ImmDrawBegin(primitive: GPU_Primitive_t);
}
extern "C" {
    pub fn C3D_ImmSendAttrib(x: f32, y: f32, z: f32, w: f32);
}
extern "C" {
    pub fn C3D_ImmDrawEnd();
}
extern "C" {
    pub fn C3D_FixedAttribGetWritePtr(id: ::libc::c_int) -> *mut C3D_FVec;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_TexEnv {
    pub srcRgb: u16_,
    pub srcAlpha: u16_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1,
    pub funcRgb: u16_,
    pub funcAlpha: u16_,
    pub color: u32_,
    pub scaleRgb: u16_,
    pub scaleAlpha: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_TexEnv__bindgen_ty_1 {
    pub opAll: u32_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn opRgb(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opRgb(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn opAlpha(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opAlpha(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(opRgb: u32_, opAlpha: u32_) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let opRgb: u32 = unsafe { ::core::mem::transmute(opRgb) };
            opRgb as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let opAlpha: u32 = unsafe { ::core::mem::transmute(opAlpha) };
            opAlpha as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_RGB: C3D_TexEnvMode = 1;
pub const C3D_Alpha: C3D_TexEnvMode = 2;
pub const C3D_Both: C3D_TexEnvMode = 3;
pub type C3D_TexEnvMode = ::libc::c_uint;
extern "C" {
    pub fn C3D_GetTexEnv(id: ::libc::c_int) -> *mut C3D_TexEnv;
}
extern "C" {
    pub fn C3D_SetTexEnv(id: ::libc::c_int, env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_DirtyTexEnv(env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_TexEnvBufUpdate(mode: ::libc::c_int, mask: ::libc::c_int);
}
extern "C" {
    pub fn C3D_TexEnvBufColor(color: u32_);
}
extern "C" {
    pub fn C3D_DepthMap(bIsZBuffer: bool, zScale: f32, zOffset: f32);
}
extern "C" {
    pub fn C3D_CullFace(mode: GPU_CULLMODE);
}
extern "C" {
    pub fn C3D_StencilTest(
        enable: bool,
        function: GPU_TESTFUNC,
        ref_: ::libc::c_int,
        inputMask: ::libc::c_int,
        writeMask: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_StencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP);
}
extern "C" {
    pub fn C3D_BlendingColor(color: u32_);
}
extern "C" {
    pub fn C3D_EarlyDepthTest(enable: bool, function: GPU_EARLYDEPTHFUNC, ref_: u32_);
}
extern "C" {
    pub fn C3D_DepthTest(enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK);
}
extern "C" {
    pub fn C3D_AlphaTest(enable: bool, function: GPU_TESTFUNC, ref_: ::libc::c_int);
}
extern "C" {
    pub fn C3D_AlphaBlend(
        colorEq: GPU_BLENDEQUATION,
        alphaEq: GPU_BLENDEQUATION,
        srcClr: GPU_BLENDFACTOR,
        dstClr: GPU_BLENDFACTOR,
        srcAlpha: GPU_BLENDFACTOR,
        dstAlpha: GPU_BLENDFACTOR,
    );
}
extern "C" {
    pub fn C3D_ColorLogicOp(op: GPU_LOGICOP);
}
extern "C" {
    pub fn C3D_FragOpMode(mode: GPU_FRAGOPMODE);
}
extern "C" {
    pub fn C3D_FragOpShadow(scale: f32, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> usize {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: usize) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: usize) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexInitParams {
    pub width: u16_,
    pub height: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_TexInitParams {
    #[inline]
    pub fn maxLevel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_maxLevel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_format(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn onVram(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onVram(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maxLevel: u8_,
        format: GPU_TEXCOLOR,
        type_: GPU_TEXTURE_MODE_PARAM,
        onVram: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let maxLevel: u8 = unsafe { ::core::mem::transmute(maxLevel) };
            maxLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let format: u32 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let onVram: u8 = unsafe { ::core::mem::transmute(onVram) };
            onVram as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn C3D_TexInitWithParams(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        p: C3D_TexInitParams,
    ) -> bool;
}
extern "C" {
    pub fn C3D_TexLoadImage(
        tex: *mut C3D_Tex,
        data: *const ::libc::c_void,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_TexGenerateMipmap(tex: *mut C3D_Tex, face: GPU_TEXFACE);
}
extern "C" {
    pub fn C3D_TexBind(unitId: ::libc::c_int, tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexFlush(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexDelete(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexShadowParams(perspective: bool, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTexColorLut {
    pub color: [u32_; 256usize],
    pub diff: [u32_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTex {
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_ProcTex__bindgen_ty_2,
    pub __bindgen_anon_3: C3D_ProcTex__bindgen_ty_3,
    pub __bindgen_anon_4: C3D_ProcTex__bindgen_ty_4,
    pub __bindgen_anon_5: C3D_ProcTex__bindgen_ty_5,
    pub __bindgen_anon_6: C3D_ProcTex__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_1 {
    pub proctex0: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn uClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn vClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rgbFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaSeparate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSeparate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNoise(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enableNoise(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasLow(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasLow(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uClamp: u32_,
        vClamp: u32_,
        rgbFunc: u32_,
        alphaFunc: u32_,
        alphaSeparate: bool,
        enableNoise: bool,
        uShift: u32_,
        vShift: u32_,
        lodBiasLow: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let uClamp: u32 = unsafe { ::core::mem::transmute(uClamp) };
            uClamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vClamp: u32 = unsafe { ::core::mem::transmute(vClamp) };
            vClamp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let rgbFunc: u32 = unsafe { ::core::mem::transmute(rgbFunc) };
            rgbFunc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let alphaFunc: u32 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let alphaSeparate: u8 = unsafe { ::core::mem::transmute(alphaSeparate) };
            alphaSeparate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableNoise: u8 = unsafe { ::core::mem::transmute(enableNoise) };
            enableNoise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let uShift: u32 = unsafe { ::core::mem::transmute(uShift) };
            uShift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vShift: u32 = unsafe { ::core::mem::transmute(vShift) };
            vShift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let lodBiasLow: u32 = unsafe { ::core::mem::transmute(lodBiasLow) };
            lodBiasLow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_2 {
    pub proctex1: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 {
    pub uNoiseAmpl: u16_,
    pub uNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_3 {
    pub proctex2: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 {
    pub vNoiseAmpl: u16_,
    pub vNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_4 {
    pub proctex3: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 {
    pub uNoiseFreq: u16_,
    pub vNoiseFreq: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_5 {
    pub proctex4: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn minFilter(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_minFilter(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unknown1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasHigh(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasHigh(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minFilter: u32_,
        unknown1: u32_,
        width: u32_,
        lodBiasHigh: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let minFilter: u32 = unsafe { ::core::mem::transmute(minFilter) };
            minFilter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let unknown1: u32 = unsafe { ::core::mem::transmute(unknown1) };
            unknown1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let lodBiasHigh: u32 = unsafe { ::core::mem::transmute(lodBiasHigh) };
            lodBiasHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_6 {
    pub proctex5: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown2(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_unknown2(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32_, unknown2: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let unknown2: u32 = unsafe { ::core::mem::transmute(unknown2) };
            unknown2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_ProcTex_U: _bindgen_ty_39 = 1;
pub const C3D_ProcTex_V: _bindgen_ty_39 = 2;
pub const C3D_ProcTex_UV: _bindgen_ty_39 = 3;
pub type _bindgen_ty_39 = ::libc::c_uint;
extern "C" {
    pub fn C3D_ProcTexInit(pt: *mut C3D_ProcTex, offset: ::libc::c_int, length: ::libc::c_int);
}
extern "C" {
    pub fn C3D_ProcTexNoiseCoefs(
        pt: *mut C3D_ProcTex,
        mode: ::libc::c_int,
        amplitude: f32,
        frequency: f32,
        phase: f32,
    );
}
extern "C" {
    pub fn C3D_ProcTexLodBias(pt: *mut C3D_ProcTex, bias: f32);
}
extern "C" {
    pub fn C3D_ProcTexBind(texCoordId: ::libc::c_int, pt: *mut C3D_ProcTex);
}
pub type C3D_ProcTexLut = [u32_; 128usize];
extern "C" {
    pub fn C3D_ProcTexLutBind(id: GPU_PROCTEX_LUTID, lut: *mut C3D_ProcTexLut);
}
extern "C" {
    pub fn ProcTexLut_FromArray(lut: *mut C3D_ProcTexLut, in_: *const f32);
}
extern "C" {
    pub fn C3D_ProcTexColorLutBind(lut: *mut C3D_ProcTexColorLut);
}
extern "C" {
    pub fn ProcTexColorLut_Write(
        out: *mut C3D_ProcTexColorLut,
        in_: *const u32_,
        offset: ::libc::c_int,
        length: ::libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLut {
    pub data: [u32_; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutDA {
    pub lut: C3D_LightLut,
    pub bias: f32,
    pub scale: f32,
}
pub type C3D_LightLutFunc = ::core::option::Option<unsafe extern "C" fn(x: f32, param: f32) -> f32>;
pub type C3D_LightLutFuncDA =
    ::core::option::Option<unsafe extern "C" fn(dist: f32, arg0: f32, arg1: f32) -> f32>;
extern "C" {
    pub fn LightLut_FromArray(lut: *mut C3D_LightLut, data: *mut f32);
}
extern "C" {
    pub fn LightLut_FromFunc(
        lut: *mut C3D_LightLut,
        func: C3D_LightLutFunc,
        param: f32,
        negative: bool,
    );
}
extern "C" {
    pub fn LightLutDA_Create(
        lut: *mut C3D_LightLutDA,
        func: C3D_LightLutFuncDA,
        from: f32,
        to: f32,
        arg0: f32,
        arg1: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Material {
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub emission: [f32; 3usize],
}
pub type C3D_Light = C3D_Light_t;
pub type C3D_LightEnv = C3D_LightEnv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutInputConf {
    pub abs: u32_,
    pub select: u32_,
    pub scale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnvConf {
    pub ambient: u32_,
    pub numLights: u32_,
    pub config: [u32_; 2usize],
    pub lutInput: C3D_LightLutInputConf,
    pub permutation: u32_,
}
pub const C3DF_LightEnv_Dirty: _bindgen_ty_40 = 1;
pub const C3DF_LightEnv_MtlDirty: _bindgen_ty_40 = 2;
pub const C3DF_LightEnv_LCDirty: _bindgen_ty_40 = 4;
pub type _bindgen_ty_40 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnv_t {
    pub flags: u32_,
    pub luts: [*mut C3D_LightLut; 6usize],
    pub ambient: [f32; 3usize],
    pub lights: [*mut C3D_Light; 8usize],
    pub conf: C3D_LightEnvConf,
    pub material: C3D_Material,
}
extern "C" {
    pub fn C3D_LightEnvInit(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvBind(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvMaterial(env: *mut C3D_LightEnv, mtl: *const C3D_Material);
}
extern "C" {
    pub fn C3D_LightEnvAmbient(env: *mut C3D_LightEnv, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightEnvLut(
        env: *mut C3D_LightEnv,
        lutId: GPU_LIGHTLUTID,
        input: GPU_LIGHTLUTINPUT,
        negative: bool,
        lut: *mut C3D_LightLut,
    );
}
pub const GPU_SHADOW_PRIMARY: _bindgen_ty_41 = 65536;
pub const GPU_SHADOW_SECONDARY: _bindgen_ty_41 = 131072;
pub const GPU_INVERT_SHADOW: _bindgen_ty_41 = 262144;
pub const GPU_SHADOW_ALPHA: _bindgen_ty_41 = 524288;
pub type _bindgen_ty_41 = ::libc::c_uint;
extern "C" {
    pub fn C3D_LightEnvFresnel(env: *mut C3D_LightEnv, selector: GPU_FRESNELSEL);
}
extern "C" {
    pub fn C3D_LightEnvBumpMode(env: *mut C3D_LightEnv, mode: GPU_BUMPMODE);
}
extern "C" {
    pub fn C3D_LightEnvBumpSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvShadowMode(env: *mut C3D_LightEnv, mode: u32_);
}
extern "C" {
    pub fn C3D_LightEnvShadowSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvClampHighlights(env: *mut C3D_LightEnv, clamp: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightMatConf {
    pub specular0: u32_,
    pub specular1: u32_,
    pub diffuse: u32_,
    pub ambient: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightConf {
    pub material: C3D_LightMatConf,
    pub position: [u16_; 3usize],
    pub padding0: u16_,
    pub spotDir: [u16_; 3usize],
    pub padding1: u16_,
    pub padding2: u32_,
    pub config: u32_,
    pub distAttnBias: u32_,
    pub distAttnScale: u32_,
}
pub const C3DF_Light_Enabled: _bindgen_ty_42 = 1;
pub const C3DF_Light_Dirty: _bindgen_ty_42 = 2;
pub const C3DF_Light_MatDirty: _bindgen_ty_42 = 4;
pub const C3DF_Light_SPDirty: _bindgen_ty_42 = 16384;
pub const C3DF_Light_DADirty: _bindgen_ty_42 = 32768;
pub type _bindgen_ty_42 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Light_t {
    pub flags: u16_,
    pub id: u16_,
    pub parent: *mut C3D_LightEnv,
    pub lut_SP: *mut C3D_LightLut,
    pub lut_DA: *mut C3D_LightLut,
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub conf: C3D_LightConf,
}
extern "C" {
    pub fn C3D_LightInit(light: *mut C3D_Light, env: *mut C3D_LightEnv) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_LightEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightTwoSideDiffuse(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightGeoFactor(light: *mut C3D_Light, id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn C3D_LightAmbient(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightDiffuse(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular0(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular1(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightPosition(light: *mut C3D_Light, pos: *mut C3D_FVec);
}
extern "C" {
    pub fn C3D_LightShadowEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotDir(light: *mut C3D_Light, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn C3D_LightSpotLut(light: *mut C3D_Light, lut: *mut C3D_LightLut);
}
extern "C" {
    pub fn C3D_LightDistAttnEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightDistAttn(light: *mut C3D_Light, lut: *mut C3D_LightLutDA);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FogLut {
    pub data: [u32_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_GasLut {
    pub diff: [u32_; 8usize],
    pub color: [u32_; 8usize],
}
extern "C" {
    pub fn FogLut_FromArray(lut: *mut C3D_FogLut, data: *const f32);
}
extern "C" {
    pub fn FogLut_Exp(lut: *mut C3D_FogLut, density: f32, gradient: f32, near: f32, far: f32);
}
extern "C" {
    pub fn C3D_FogGasMode(fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool);
}
extern "C" {
    pub fn C3D_FogColor(color: u32_);
}
extern "C" {
    pub fn C3D_FogLutBind(lut: *mut C3D_FogLut);
}
extern "C" {
    pub fn GasLut_FromArray(lut: *mut C3D_GasLut, data: *const u32_);
}
extern "C" {
    pub fn C3D_GasBeginAcc();
}
extern "C" {
    pub fn C3D_GasDeltaZ(value: f32);
}
extern "C" {
    pub fn C3D_GasAccMax(value: f32);
}
extern "C" {
    pub fn C3D_GasAttn(value: f32);
}
extern "C" {
    pub fn C3D_GasLightPlanar(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightView(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightDirection(dotp: f32);
}
extern "C" {
    pub fn C3D_GasLutInput(input: GPU_GASLUTINPUT);
}
extern "C" {
    pub fn C3D_GasLutBind(lut: *mut C3D_GasLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_CLEAR_COLOR: C3D_ClearBits = 1;
pub const C3D_CLEAR_DEPTH: C3D_ClearBits = 2;
pub const C3D_CLEAR_ALL: C3D_ClearBits = 3;
pub type C3D_ClearBits = ::libc::c_uint;
extern "C" {
    pub fn C3D_CalcColorBufSize(width: u32_, height: u32_, fmt: GPU_COLORBUF) -> u32_;
}
extern "C" {
    pub fn C3D_CalcDepthBufSize(width: u32_, height: u32_, fmt: GPU_DEPTHBUF) -> u32_;
}
extern "C" {
    pub fn C3D_GetFrameBuf() -> *mut C3D_FrameBuf;
}
extern "C" {
    pub fn C3D_SetFrameBuf(fb: *mut C3D_FrameBuf);
}
extern "C" {
    pub fn C3D_FrameBufTex(
        fb: *mut C3D_FrameBuf,
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_FrameBufClear(
        fb: *mut C3D_FrameBuf,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
extern "C" {
    pub fn C3D_FrameBufTransfer(
        fb: *mut C3D_FrameBuf,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
pub const C3D_FRAME_SYNCDRAW: _bindgen_ty_43 = 1;
pub const C3D_FRAME_NONBLOCK: _bindgen_ty_43 = 2;
pub type _bindgen_ty_43 = ::libc::c_uint;
extern "C" {
    pub fn C3D_FrameRate(fps: f32) -> f32;
}
extern "C" {
    pub fn C3D_FrameSync();
}
extern "C" {
    pub fn C3D_FrameCounter(id: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn C3D_FrameBegin(flags: u8_) -> bool;
}
extern "C" {
    pub fn C3D_FrameDrawOn(target: *mut C3D_RenderTarget) -> bool;
}
extern "C" {
    pub fn C3D_FrameSplit(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEnd(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEndHook(
        hook: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        param: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_GetDrawingTime() -> f32;
}
extern "C" {
    pub fn C3D_GetProcessingTime() -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_DEPTHTYPE {
    pub __i: ::libc::c_int,
    pub __e: GPU_DEPTHBUF,
}
extern "C" {
    pub fn C3D_RenderTargetCreate(
        width: ::libc::c_int,
        height: ::libc::c_int,
        colorFmt: GPU_COLORBUF,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetCreateFromTex(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetDelete(target: *mut C3D_RenderTarget);
}
extern "C" {
    pub fn C3D_RenderTargetSetOutput(
        target: *mut C3D_RenderTarget,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncDisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncTextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncMemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    );
}
pub type FILE = __FILE;
#[doc = " @brief Subtexture"]
#[doc = "  @note If top > bottom, the subtexture is rotated 1/4 revolution counter-clockwise"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_SubTexture {
    #[doc = "< Sub-texture width (pixels)"]
    pub width: u16_,
    #[doc = "< Sub-texture height (pixels)"]
    pub height: u16_,
    #[doc = "< Left u-coordinate"]
    pub left: f32,
    #[doc = "< Top v-coordinate"]
    pub top: f32,
    #[doc = "< Right u-coordinate"]
    pub right: f32,
    #[doc = "< Bottom v-coordinate"]
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_Texture_s {
    _unused: [u8; 0],
}
#[doc = " @brief Texture"]
pub type Tex3DS_Texture = *mut Tex3DS_Texture_s;
extern "C" {
    #[doc = " @brief Import Tex3DS texture"]
    #[doc = "  @param[in]  input   Input data"]
    #[doc = "  @param[in]  insize  Size of the input data"]
    #[doc = "  @param[out] tex     citro3d texture"]
    #[doc = "  @param[out] texcube citro3d texcube"]
    #[doc = "  @param[in]  vram    Whether to store textures in VRAM"]
    #[doc = "  @returns Tex3DS texture"]
    pub fn Tex3DS_TextureImport(
        input: *const ::libc::c_void,
        insize: usize,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
extern "C" {
    #[doc = " @brief Import Tex3DS texture"]
    #[doc = ""]
    #[doc = "  @description"]
    #[doc = "  For example, use this if you want to import from a large file without"]
    #[doc = "  pulling the entire file into memory."]
    #[doc = ""]
    #[doc = "  @param[out] tex      citro3d texture"]
    #[doc = "  @param[out] texcube  citro3d texcube"]
    #[doc = "  @param[in]  vram     Whether to store textures in VRAM"]
    #[doc = "  @param[in]  callback Data callback"]
    #[doc = "  @param[in]  userdata User data passed to callback"]
    #[doc = "  @returns Tex3DS texture"]
    pub fn Tex3DS_TextureImportCallback(
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
    ) -> Tex3DS_Texture;
}
extern "C" {
    #[doc = " @brief Import Tex3DS texture"]
    #[doc = ""]
    #[doc = "  Starts reading at the current file descriptor's offset. The file"]
    #[doc = "  descriptor's position is left at the end of the decoded data. On error, the"]
    #[doc = "  file descriptor's position is indeterminate."]
    #[doc = ""]
    #[doc = "  @param[in]  fd       Open file descriptor"]
    #[doc = "  @param[out] tex      citro3d texture"]
    #[doc = "  @param[out] texcube  citro3d texcube"]
    #[doc = "  @param[in]  vram     Whether to store textures in VRAM"]
    #[doc = "  @returns Tex3DS texture"]
    pub fn Tex3DS_TextureImportFD(
        fd: ::libc::c_int,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
extern "C" {
    #[doc = " @brief Import Tex3DS texture"]
    #[doc = ""]
    #[doc = "  Starts reading at the current file stream's offset. The file stream's"]
    #[doc = "  position is left at the end of the decoded data. On error, the file"]
    #[doc = "  stream's position is indeterminate."]
    #[doc = ""]
    #[doc = "  @param[in]  fp       Open file stream"]
    #[doc = "  @param[out] tex      citro3d texture"]
    #[doc = "  @param[out] texcube  citro3d texcube"]
    #[doc = "  @param[in]  vram     Whether to store textures in VRAM"]
    #[doc = "  @returns Tex3DS texture"]
    pub fn Tex3DS_TextureImportStdio(
        fp: *mut FILE,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
extern "C" {
    #[doc = " @brief Get number of subtextures"]
    #[doc = "  @param[in] texture Tex3DS texture"]
    #[doc = "  @returns Number of subtextures"]
    pub fn Tex3DS_GetNumSubTextures(texture: Tex3DS_Texture) -> usize;
}
extern "C" {
    #[doc = " @brief Get subtexture"]
    #[doc = "  @param[in] texture Tex3DS texture"]
    #[doc = "  @param[in] index   Subtexture index"]
    #[doc = "  @returns Subtexture info"]
    pub fn Tex3DS_GetSubTexture(texture: Tex3DS_Texture, index: usize) -> *const Tex3DS_SubTexture;
}
extern "C" {
    #[doc = " @brief Free Tex3DS texture"]
    #[doc = "  @param[in] texture Tex3DS texture to free"]
    pub fn Tex3DS_TextureFree(texture: Tex3DS_Texture);
}
